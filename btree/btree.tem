// constructor
template <typename T>
btree<T>::btree(size_t maxNodeElems) {
   root = new node<T>(maxNodeElems); 
}

// Copy constructor
template <typename T>
btree<T>::btree(const btree<T>& original) {
    // do many things
}

// move constructor
template <typename T>
btree<T>::btree(btree<T>&& original) {
    // do many things
}

// copy assignment
template <typename T>
btree<T>& btree<T>::operator=(const btree<T>& rhs) {
    // do many things
}

// move assignment
template <typename T>
btree<T>& btree<T>::operator=(btree<T>&& rhs) {
    // do many things
}

// output tree to stream with space delimiter
template <typename T>
std::ostream& operator<<(std::ostream& os, const btree<T>& tree) {

    os << "HI!";
    return os;
}

// insert into the tree
template <typename T>
std::pair<btree_iterator<T>, bool> btree<T>::insert(const T& elem) {

    return make_pair (btree_iterator<T>(), true);
}

// iterator
template <typename T>
btree_iterator<T> btree<T>::find(const T& elem) {
    return btree_iterator<T>();
}

// const_iterator
template <typename T>
const_btree_iterator<T> btree<T>::find(const T& elem) const {
    return const_btree_iterator<T>();
}

// destructor
template <typename T>
btree<T>::~btree() {};

/***********************/
/* Node Implementation */
/***********************/

// node constructor
template <typename T>
node<T>::node (const unsigned int node_size) : 
    node_size_(node_size), parent_(nullptr), max_children_(node_size + 1),
    max_children_index_(node_size) {
#ifdef _DEBUG_
    std::cout << "Node being constructed.\n";
#endif
    // There is one more children than there is data items
    unsigned int number = node_size + 1;
    children_ = new node<T>* [number];
    unsigned int idx = 0;
    while (idx < number) {
        children_[idx] = nullptr;
        idx++;
    }
}

// node destructor
template <typename T>
node<T>::~node () {
    // data_ does not need explicit deletion.
    // Call destructors of each child.
    unsigned int idx = 0;
    // There is one more child than node_size_
    while (idx <= node_size_) {
        if (children_[idx] != nullptr) {
            delete children_[idx];
        }
        idx++;
    }
}

// insert an element into the btree
template <typename T>
bool node<T>::insert (const T& elem) {
    // Lets see if it has a place in this node
    if (data_.size() < node_size_) {
        unsigned int idx = 0;
        auto i = data_.begin();
        for (; i != data_.end(); ++i) {
            if (*i == elem) { // It's already there
                return false;
            } else if (*i > elem) { // it goes on the left.
                break;
            }
            idx++;
        }
        // If it hasn't reached data.end(), it's on the left of some element.
        // iterator.insert behaves exactly like this
        if (i != data_.end()) {
            data_.insert (i, elem);
        // The iterator reached the end, indicating the correct position
        // is right at the end of the list, since this node is not full
        } else if (i == data_.end()) {
            data_.push_back (elem);
        } 
        return true; 
    // no room here, delegate to a child
    } else {
#ifdef _DEBUG_
        std::cout << "Insertion needs to delegate.\n";
#endif
        unsigned int childIndex = 0;
        for (auto dataItem = data_.begin(); dataItem != data_.end(); ++dataItem) {
            if (*dataItem > elem) { // it goes on the left of this one
#ifdef _DEBUG_
                std::cout << "Insertion is delegating to the child left of " << *dataItem << "\n";
#endif
                if (children_[childIndex] == nullptr) {
#ifdef _DEBUG_
                std::cout << "Insertion has found it's null, spawning a child" << "\n";
#endif
                    children_[childIndex] = new node<T> (node_size_);
                    children_[childIndex]->parent_ = this;
                }
                return children_[childIndex]->insert (elem);
            }
            childIndex++;
        }
        // If it reached here, It must be on the right of the last element.
#ifdef _DEBUG_
        std::cout << "Insertion has not found a suitable left child, delegating to child in slot " << childIndex << "\n";
#endif
        if (children_[childIndex] == nullptr) {
            children_[childIndex] = new node<T> (node_size_);
            children_[childIndex]->parent_ = this;
        }
        return children_[childIndex]->insert (elem);
    }

    // Should never reach this point.
    assert (false);
    return false;
}

// find an element in the btree
template <typename T>
bool node<T>::find (const T& elem) {
    // See if the element is here
    unsigned int index = 0;
    auto i = data_.begin();
    for (;i != data_.end(); ++i) {
        if (*i == elem) {
            return true;
        }
        if (*i > elem) { // Left child
            if (children_[index] != nullptr) {
#ifdef _DEBUG_
                std::cout << "Find delegating to a child on the left of " << *i << "\n";
#endif
                return children_[index]->find (elem);
            } else {
#ifdef _DEBUG_
                std::cout << "Find wanted to delegate to a child on he left of " << *i << " but it was null\n";;
#endif
                return false;
            }
        }
        index++;
    }

    // If we get to this point, it wasn't on the left of any element
    // There's only one spot left, the rightmost slot.
    // It just so happens that index is also this index, since it is post incremented.
    if (children_[index] == nullptr) {
        return false;
    } else {
        return children_[index]->find (elem);
    }
}

